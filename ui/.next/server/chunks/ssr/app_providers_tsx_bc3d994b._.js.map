{"version":3,"sources":["../../../../node_modules/graphql/language/printer.mjs","../../../../app/providers.tsx","../../../../node_modules/%40apollo/src/link/http/selectURI.ts","../../../../node_modules/%40apollo/src/cache/inmemory/reactiveVars.ts","../../../../node_modules/%40apollo/src/utilities/graphql/DocumentTransform.ts","../../../../node_modules/%40apollo/src/masking/utils.ts","../../../../node_modules/%40apollo/src/masking/maskDefinition.ts","../../../../node_modules/%40apollo/src/masking/maskFragment.ts","../../../../node_modules/%40apollo/src/utilities/graphql/print.ts","../../../../node_modules/%40apollo/src/link/retry/retryFunction.ts","../../../../node_modules/%40apollo/src/masking/maskOperation.ts","../../../../node_modules/%40apollo/src/cache/inmemory/key-extractor.ts","../../../../node_modules/%40apollo/src/utilities/observables/asyncMap.ts","../../../../node_modules/%40apollo/src/link/core/execute.ts","../../../../node_modules/%40apollo/src/link/utils/fromError.ts","../../../../node_modules/%40apollo/src/link/core/from.ts","../../../../node_modules/%40apollo/src/cache/inmemory/helpers.ts","../../../../node_modules/%40apollo/src/utilities/common/incrementalResult.ts","../../../../node_modules/%40apollo/src/utilities/common/errorHandling.ts","../../../../node_modules/%40apollo/src/link/utils/transformOperation.ts","../../../../node_modules/%40apollo/src/link/http/serializeFetchParameter.ts","../../../../node_modules/%40apollo/src/link/core/ApolloLink.ts","../../../../node_modules/%40apollo/src/link/http/checkFetcher.ts","../../../../node_modules/%40apollo/src/link/utils/validateOperation.ts","../../../../node_modules/%40apollo/src/link/http/rewriteURIForGET.ts","../../../../node_modules/%40apollo/src/link/retry/delayFunction.ts","../../../../node_modules/%40apollo/src/link/utils/createOperation.ts","../../../../node_modules/graphql/language/predicates.mjs","../../../../node_modules/%40apollo/src/link/utils/filterOperationVariables.ts","../../../../node_modules/%40apollo/src/cache/inmemory/entityStore.ts","../../../../node_modules/%40apollo/src/react/context/ApolloProvider.tsx","../../../../node_modules/%40apollo/src/cache/inmemory/readFromStore.ts","../../../../node_modules/%40apollo/src/core/ApolloClient.ts","../../../../node_modules/%40apollo/src/cache/inmemory/policies.ts","../../../../node_modules/%40apollo/src/link/http/createHttpLink.ts","../../../../node_modules/%40apollo/src/core/LocalState.ts","../../../../node_modules/%40apollo/src/core/QueryInfo.ts","../../../../node_modules/%40apollo/src/cache/inmemory/object-canon.ts","../../../../node_modules/%40apollo/src/core/QueryManager.ts","../../../../node_modules/%40apollo/src/utilities/graphql/transform.ts","../../../../node_modules/graphql/language/printString.mjs","../../../../node_modules/%40apollo/src/link/retry/retryLink.ts","../../../../node_modules/%40apollo/src/link/http/responseIterator.ts","../../../../node_modules/%40apollo/src/link/http/iterators/nodeStream.ts","../../../../node_modules/%40apollo/src/link/http/iterators/reader.ts","../../../../node_modules/%40apollo/src/link/http/iterators/promise.ts","../../../../node_modules/%40apollo/src/link/http/parseAndCheckHttpResponse.ts","../../../../node_modules/%40apollo/src/cache/core/cache.ts","../../../../node_modules/%40apollo/src/cache/inmemory/writeToStore.ts","../../../../node_modules/%40apollo/src/link/http/iterators/async.ts","../../../../node_modules/%40apollo/src/link/http/HttpLink.ts","../../../../node_modules/%40apollo/src/cache/inmemory/inMemoryCache.ts","../../../../node_modules/%40apollo/src/utilities/observables/Concast.ts","../../../../lib/apollo.tsx","../../../../node_modules/%40apollo/src/link/http/selectHttpOptionsAndBody.ts","../../../../node_modules/%40apollo/src/utilities/common/mergeDeep.ts","../../../../node_modules/%40apollo/src/cache/core/types/common.ts","../../../../node_modules/%40apollo/src/link/error/index.ts","../../../../node_modules/%40apollo/src/link/utils/throwServerError.ts"],"sourcesContent":["import { printBlockString } from './blockString.mjs';\nimport { printString } from './printString.mjs';\nimport { visit } from './visitor.mjs';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, printDocASTReducer);\n}\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: (node) => node.value,\n  },\n  Variable: {\n    leave: (node) => '$' + node.name,\n  },\n  // Document\n  Document: {\n    leave: (node) => join(node.definitions, '\\n\\n'),\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = hasMultilineItems(node.variableDefinitions)\n        ? wrap('(\\n', join(node.variableDefinitions, '\\n'), '\\n)')\n        : wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix =\n        wrap('', node.description, '\\n') +\n        join(\n          [\n            node.operation,\n            join([node.name, varDefs]),\n            join(node.directives, ' '),\n          ],\n          ' ',\n        ); // Anonymous queries with no directives or variable definitions can use\n      // the query short form.\n\n      return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;\n    },\n  },\n  VariableDefinition: {\n    leave: ({ variable, type, defaultValue, directives, description }) =>\n      wrap('', description, '\\n') +\n      variable +\n      ': ' +\n      type +\n      wrap(' = ', defaultValue) +\n      wrap(' ', join(directives, ' ')),\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block(selections),\n  },\n  Field: {\n    leave({ alias, name, arguments: args, directives, selectionSet }) {\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    },\n  },\n  Argument: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: ({ name, directives }) =>\n      '...' + name + wrap(' ', join(directives, ' ')),\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) =>\n      join(\n        [\n          '...',\n          wrap('on ', typeCondition),\n          join(directives, ' '),\n          selectionSet,\n        ],\n        ' ',\n      ),\n  },\n  FragmentDefinition: {\n    leave: ({\n      name,\n      typeCondition,\n      variableDefinitions,\n      directives,\n      selectionSet,\n      description,\n    }) =>\n      wrap('', description, '\\n') + // Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n      `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n      selectionSet,\n  },\n  // Value\n  IntValue: {\n    leave: ({ value }) => value,\n  },\n  FloatValue: {\n    leave: ({ value }) => value,\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) =>\n      isBlockString ? printBlockString(value) : printString(value),\n  },\n  BooleanValue: {\n    leave: ({ value }) => (value ? 'true' : 'false'),\n  },\n  NullValue: {\n    leave: () => 'null',\n  },\n  EnumValue: {\n    leave: ({ value }) => value,\n  },\n  ListValue: {\n    leave: ({ values }) => '[' + join(values, ', ') + ']',\n  },\n  ObjectValue: {\n    leave: ({ fields }) => '{' + join(fields, ', ') + '}',\n  },\n  ObjectField: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Directive\n  Directive: {\n    leave: ({ name, arguments: args }) =>\n      '@' + name + wrap('(', join(args, ', '), ')'),\n  },\n  // Type\n  NamedType: {\n    leave: ({ name }) => name,\n  },\n  ListType: {\n    leave: ({ type }) => '[' + type + ']',\n  },\n  NonNullType: {\n    leave: ({ type }) => type + '!',\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) =>\n      wrap('', description, '\\n') +\n      join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type }) => operation + ': ' + type,\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') +\n      join(['scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  FieldDefinition: {\n    leave: ({ description, name, arguments: args, type, directives }) =>\n      wrap('', description, '\\n') +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      ': ' +\n      type +\n      wrap(' ', join(directives, ' ')),\n  },\n  InputValueDefinition: {\n    leave: ({ description, name, type, defaultValue, directives }) =>\n      wrap('', description, '\\n') +\n      join(\n        [name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')],\n        ' ',\n      ),\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name, directives, types }) =>\n      wrap('', description, '\\n') +\n      join(\n        ['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))],\n        ' ',\n      ),\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name, directives, values }) =>\n      wrap('', description, '\\n') +\n      join(['enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') + join([name, join(directives, ' ')], ' '),\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(['input', name, join(directives, ' '), block(fields)], ' '),\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name, arguments: args, repeatable, locations }) =>\n      wrap('', description, '\\n') +\n      'directive @' +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      (repeatable ? ' repeatable' : '') +\n      ' on ' +\n      join(locations, ' | '),\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) =>\n      join(\n        ['extend schema', join(directives, ' '), block(operationTypes)],\n        ' ',\n      ),\n  },\n  ScalarTypeExtension: {\n    leave: ({ name, directives }) =>\n      join(['extend scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeExtension: {\n    leave: ({ name, directives, types }) =>\n      join(\n        [\n          'extend union',\n          name,\n          join(directives, ' '),\n          wrap('= ', join(types, ' | ')),\n        ],\n        ' ',\n      ),\n  },\n  EnumTypeExtension: {\n    leave: ({ name, directives, values }) =>\n      join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name, directives, fields }) =>\n      join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n  },\n  // Schema Coordinates\n  TypeCoordinate: {\n    leave: ({ name }) => name,\n  },\n  MemberCoordinate: {\n    leave: ({ name, memberName }) => join([name, wrap('.', memberName)]),\n  },\n  ArgumentCoordinate: {\n    leave: ({ name, fieldName, argumentName }) =>\n      join([name, wrap('.', fieldName), wrap('(', argumentName, ':)')]),\n  },\n  DirectiveCoordinate: {\n    leave: ({ name }) => join(['@', name]),\n  },\n  DirectiveArgumentCoordinate: {\n    leave: ({ name, argumentName }) =>\n      join(['@', name, wrap('(', argumentName, ':)')]),\n  },\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\nfunction join(maybeArray, separator = '') {\n  var _maybeArray$filter$jo;\n\n  return (_maybeArray$filter$jo =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.filter((x) => x).join(separator)) !== null &&\n    _maybeArray$filter$jo !== void 0\n    ? _maybeArray$filter$jo\n    : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\nfunction wrap(start, maybeString, end = '') {\n  return maybeString != null && maybeString !== ''\n    ? start + maybeString + end\n    : '';\n}\n\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n  return (_maybeArray$some =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.some((str) => str.includes('\\n'))) !== null &&\n    _maybeArray$some !== void 0\n    ? _maybeArray$some\n    : false;\n}\n","'use client'\n\nimport React from 'react'\nimport { ApolloProvider } from '@apollo/client'\nimport { apolloClient } from '@/lib/apollo'\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    <ApolloProvider client={apolloClient}>\n      {children}\n    </ApolloProvider>\n  )\n}\n","import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n","import type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep, Slot } from \"optimism\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { ApolloCache } from \"../../core/index.js\";\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache<any>): this;\n  forgetCache(cache: ApolloCache<any>): boolean;\n}\n\nexport type ReactiveListener<T> = (value: T) => any;\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache<any>>();\n\nconst cacheInfoMap = new WeakMap<\n  ApolloCache<any>,\n  {\n    vars: Set<ReactiveVar<any>>;\n    dep: OptimisticDependencyFunction<ReactiveVar<any>>;\n  }\n>();\n\nfunction getCacheInfo(cache: ApolloCache<any>) {\n  let info = cacheInfoMap.get(cache)!;\n  if (!info) {\n    cacheInfoMap.set(\n      cache,\n      (info = {\n        vars: new Set(),\n        dep: dep(),\n      })\n    );\n  }\n  return info;\n}\n\nexport function forgetCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache<any>>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        caches.forEach((cache) => {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        const oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach((listener) => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = (listener) => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = (rv.attachCache = (cache) => {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  });\n\n  rv.forgetCache = (cache) => caches.delete(cache);\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache<any> & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n","import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can speed up repeated calls to the document transform for the same input document. Set to `false` to completely disable caching for the document transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey) option.\n   *\n   * The default value is `true`.\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > **Note:** The items in the array may be any type, but also need to be referentially stable to guarantee a stable cache key.\n   *\n   * The default implementation of this function returns the `document` as the cache key.\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>(canUseWeakMap);\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n","import { Slot } from \"optimism\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { canUseWeakMap, canUseWeakSet } from \"../utilities/index.js\";\n\nexport const MapImpl = canUseWeakMap ? WeakMap : Map;\nexport const SetImpl = canUseWeakSet ? WeakSet : Set;\n\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport const disableWarningsSlot = new Slot<boolean>();\n\nlet issuedWarning = false;\nexport function warnOnImproperCacheImplementation() {\n  if (!issuedWarning) {\n    issuedWarning = true;\n    invariant.warn(\n      \"The configured cache does not support data masking which effectively disables it. Please use a cache that supports data masking or disable data masking to silence this warning. Caches will be required to support the necessary data masking APIs in Apollo Client 4.0.\"\n    );\n  }\n}\n","import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n","import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"../utilities/index.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache<unknown>,\n  fragmentName?: string\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n","import type { ASTNode } from \"graphql\";\nimport { print as origPrint } from \"graphql\";\nimport {\n  AutoCleanedWeakCache,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../caching/index.js\";\nimport { registerGlobalCache } from \"../caching/getMemoryInternals.js\";\n\nlet printCache!: AutoCleanedWeakCache<ASTNode, string>;\nexport const print = Object.assign(\n  (ast: ASTNode) => {\n    let result = printCache.get(ast);\n\n    if (!result) {\n      result = origPrint(ast);\n      printCache.set(ast, result);\n    }\n    return result;\n  },\n  {\n    reset() {\n      printCache = new AutoCleanedWeakCache<ASTNode, string>(\n        cacheSizes.print || defaultCacheSizes.print\n      );\n    },\n  }\n);\nprint.reset();\n\nif (__DEV__) {\n  registerGlobalCache(\"print\", () => (printCache ? printCache.size : 0));\n}\n","import type { Operation } from \"../core/index.js\";\n\n/**\n * Advanced mode: a function that determines both whether a particular\n * response should be retried.\n */\nexport interface RetryFunction {\n  (count: number, operation: Operation, error: any): boolean | Promise<boolean>;\n}\n\nexport interface RetryFunctionOptions {\n  /**\n   * The max number of times to try a single operation before giving up.\n   *\n   * Note that this INCLUDES the initial request as part of the count.\n   * E.g. maxTries of 1 indicates no retrying should occur.\n   *\n   * Defaults to 5.  Pass Infinity for infinite retries.\n   */\n  max?: number;\n\n  /**\n   * Predicate function that determines whether a particular error should\n   * trigger a retry.\n   *\n   * For example, you may want to not retry 4xx class HTTP errors.\n   *\n   * By default, all errors are retried.\n   */\n  retryIf?: (error: any, operation: Operation) => boolean | Promise<boolean>;\n}\n\nexport function buildRetryFunction(\n  retryOptions?: RetryFunctionOptions\n): RetryFunction {\n  const { retryIf, max = 5 } = retryOptions || ({} as RetryFunctionOptions);\n  return function retryFunction(count, operation, error) {\n    if (count >= max) return false;\n    return retryIf ? retryIf(error, operation) : !!error;\n  };\n}\n","import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache<unknown>\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\n\nimport { hasOwn, isArray } from \"./helpers.js\";\nimport type {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return (\n    specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null))\n  );\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n","import type { Observer } from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\n/**\n * @deprecated `asyncMap` will be removed in Apollo Client 4.0. This function is\n * safe to use in Apollo Client 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When migrating**\n *\n * Prefer to use RxJS's built in helpers. Convert promises into observables\n * using the [`from`](https://rxjs.dev/api/index/function/from) function.\n */\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>\n): Observable<R> {\n  return new Observable<R>((observer) => {\n    let promiseQueue = {\n      // Normally we would initialize promiseQueue to Promise.resolve(), but\n      // in this case, for backwards compatibility, we need to be careful to\n      // invoke the first callback synchronously.\n      then(callback: () => any) {\n        return new Promise((resolve) => resolve(callback()));\n      },\n    } as Promise<void>;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      key: \"next\" | \"error\"\n    ): (arg: any) => void {\n      return (arg) => {\n        if (examiner) {\n          const both = () =>\n            // If the observer is closed, we don't want to continue calling the\n            // mapping function - it's result will be swallowed anyways.\n            observer.closed ?\n              /* will be swallowed */ (0 as any)\n            : examiner(arg);\n\n          promiseQueue = promiseQueue.then(both, both).then(\n            (result) => observer.next(result),\n            (error) => observer.error(error)\n          );\n        } else {\n          observer[key](arg);\n        }\n      };\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, \"next\"),\n      error: makeCallback(catchFn, \"error\"),\n      complete() {\n        // no need to reassign `promiseQueue`, after `observer.complete`,\n        // the observer will be closed and short-circuit everything anyways\n        /*promiseQueue = */ promiseQueue.then(() => observer.complete());\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const execute = ApolloLink.execute;\n","import { Observable } from \"../../utilities/index.js\";\n\n/**\n * @deprecated `fromError` will be removed in Apollo Client 4.0. This is safe\n * to use in 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When upgrading**\n *\n * Use RxJS's [`throwError`](https://rxjs.dev/api/index/function/throwError) function.\n *\n * ```ts\n * const observable = throwError(() => new Error(...));\n * ```\n */\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>((observer) => {\n    observer.error(errorValue);\n  });\n}\n","import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const from = ApolloLink.from;\n","import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id }\n        : !isNullish(_id) ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n","import type {\n  ExecutionPatchIncrementalResult,\n  ExecutionPatchInitialResult,\n  ExecutionPatchResult,\n  ApolloPayloadResult,\n  FetchResult,\n} from \"../../link/core/index.js\";\nimport { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\n\nexport function isExecutionPatchIncrementalResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchIncrementalResult {\n  return \"incremental\" in value;\n}\n\nexport function isExecutionPatchInitialResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchInitialResult<T> {\n  return \"hasNext\" in value && \"data\" in value;\n}\n\nexport function isExecutionPatchResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchResult<T> {\n  return (\n    isExecutionPatchIncrementalResult(value) ||\n    isExecutionPatchInitialResult(value)\n  );\n}\n\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(\n  value: unknown\n): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nexport function mergeIncrementalData<TData extends object>(\n  prevResult: TData,\n  result: ExecutionPatchResult<TData>\n) {\n  let mergedData = prevResult;\n  const merger = new DeepMerger();\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach(({ data, path }) => {\n      for (let i = path.length - 1; i >= 0; --i) {\n        const key = path[i];\n        const isNumericKey = !isNaN(+key);\n        const parent: Record<string | number, any> = isNumericKey ? [] : {};\n        parent[key] = data;\n        data = parent as typeof data;\n      }\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n  return mergedData as TData;\n}\n","import type { FetchResult } from \"../../link/core/index.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { isExecutionPatchIncrementalResult } from \"./incrementalResult.js\";\n\nexport function graphQLResultHasError<T>(result: FetchResult<T>): boolean {\n  const errors = getGraphQLErrorsFromResult(result);\n  return isNonEmptyArray(errors);\n}\n\nexport function getGraphQLErrorsFromResult<T>(result: FetchResult<T>) {\n  const graphQLErrors =\n    isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach((incrementalResult) => {\n      if (incrementalResult.errors) {\n        graphQLErrors.push(...incrementalResult.errors);\n      }\n    });\n  }\n  return graphQLErrors;\n}\n","import type { GraphQLRequest, Operation } from \"../core/index.js\";\nimport { getOperationName } from \"../../utilities/index.js\";\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // Best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== \"string\" ?\n        getOperationName(transformedOperation.query) || undefined\n      : \"\";\n  }\n\n  return transformedOperation as Operation;\n}\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n","import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\n\nimport type { Observer } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type {\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n  GraphQLRequest,\n} from \"./types.js\";\nimport {\n  validateOperation,\n  createOperation,\n  transformOperation,\n} from \"../utils/index.js\";\nimport { warnDeprecated } from \"../../utilities/deprecation/index.js\";\n\nfunction passthrough(op: Operation, forward: NextLink) {\n  return (forward ? forward(op) : Observable.of()) as Observable<FetchResult>;\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport class ApolloLink {\n  public static empty(): ApolloLink {\n    return new ApolloLink(() => Observable.of());\n  }\n\n  public static from(links: (ApolloLink | RequestHandler)[]): ApolloLink {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce((x, y) => x.concat(y)) as ApolloLink;\n  }\n\n  public static split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    const leftLink = toLink(left);\n    const rightLink = toLink(right || new ApolloLink(passthrough));\n\n    let ret: ApolloLink;\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      ret = new ApolloLink((operation) => {\n        return test(operation) ?\n            leftLink.request(operation) || Observable.of()\n          : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return test(operation) ?\n            leftLink.request(operation, forward) || Observable.of()\n          : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n    return Object.assign(ret, { left: leftLink, right: rightLink });\n  }\n\n  public static execute(\n    link: ApolloLink,\n    operation: GraphQLRequest\n  ): Observable<FetchResult> {\n    return (\n      link.request(\n        createOperation(\n          operation.context,\n          transformOperation(validateOperation(operation))\n        )\n      ) || Observable.of()\n    );\n  }\n\n  public static concat(\n    first: ApolloLink | RequestHandler,\n    second: ApolloLink | RequestHandler\n  ) {\n    const firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n      invariant.warn(\n        `You are calling concat on a terminating link, which will have no effect %o`,\n        firstLink\n      );\n      return firstLink;\n    }\n    const nextLink = toLink(second);\n\n    let ret: ApolloLink;\n    if (isTerminating(nextLink)) {\n      ret = new ApolloLink(\n        (operation) =>\n          firstLink.request(\n            operation,\n            (op) => nextLink.request(op) || Observable.of()\n          ) || Observable.of()\n      );\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return (\n          firstLink.request(operation, (op) => {\n            return nextLink.request(op, forward) || Observable.of();\n          }) || Observable.of()\n        );\n      });\n    }\n    return Object.assign(ret, { left: firstLink, right: nextLink });\n  }\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    return this.concat(\n      ApolloLink.split(test, left, right || new ApolloLink(passthrough))\n    );\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return ApolloLink.concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink\n  ): Observable<FetchResult> | null {\n    throw newInvariantError(\"request is not implemented\");\n  }\n\n  /**\n   * @deprecated `onError` will be removed with Apollo Client 4.0. Please\n   * discontinue using this method.\n   */\n  protected onError(\n    error: any,\n    observer?: Observer<FetchResult>\n  ): false | void {\n    if (__DEV__) {\n      warnDeprecated(\"onError\", () => {\n        invariant.warn(\n          \"[ApolloLink] `onError` is deprecated and will be removed with Apollo Client 4.0. Please discontinue using it.\"\n        );\n      });\n    }\n    if (observer && observer.error) {\n      observer.error(error);\n      // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n      return false;\n    }\n    // Throw errors will be passed to observer.error.\n    throw error;\n  }\n\n  /**\n   * @deprecated `setOnError` will be removed with Apollo Client 4.0. Please\n   * discontinue using this method.\n   */\n  public setOnError(fn: ApolloLink[\"onError\"]): this {\n    if (__DEV__) {\n      invariant.warn(\n        \"[ApolloLink] `setOnError` is deprecated and will be removed with Apollo Client 4.0. Please discontinue using it.\"\n      );\n    }\n    this.onError = fn;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly left?: ApolloLink;\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly right?: ApolloLink;\n\n  /**\n   * @internal\n   * Can be provided by a link that has an internal cache to report it's memory details.\n   */\n  getMemoryInternals?: () => unknown;\n}\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { GraphQLRequest } from \"../core/index.js\";\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    \"query\",\n    \"operationName\",\n    \"variables\",\n    \"extensions\",\n    \"context\",\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw newInvariantError(`illegal argument: %s`, key);\n    }\n  }\n\n  return operation;\n}\n","import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n","import type { Operation } from \"../core/index.js\";\n\n/**\n * Advanced mode: a function that implements the strategy for calculating delays\n * for particular responses.\n */\nexport interface DelayFunction {\n  (count: number, operation: Operation, error: any): number;\n}\n\nexport interface DelayFunctionOptions {\n  /**\n   * The number of milliseconds to wait before attempting the first retry.\n   *\n   * Delays will increase exponentially for each attempt.  E.g. if this is\n   * set to 100, subsequent retries will be delayed by 200, 400, 800, etc,\n   * until they reach maxDelay.\n   *\n   * Note that if jittering is enabled, this is the _average_ delay.\n   *\n   * Defaults to 300.\n   */\n  initial?: number;\n\n  /**\n   * The maximum number of milliseconds that the link should wait for any\n   * retry.\n   *\n   * Defaults to Infinity.\n   */\n  max?: number;\n\n  /**\n   * Whether delays between attempts should be randomized.\n   *\n   * This helps avoid thundering herd type situations by better distributing\n   * load during major outages.\n   *\n   * Defaults to true.\n   */\n  jitter?: boolean;\n}\n\nexport function buildDelayFunction(\n  delayOptions?: DelayFunctionOptions\n): DelayFunction {\n  const { initial = 300, jitter = true, max = Infinity } = delayOptions || {};\n  // If we're jittering, baseDelay is half of the maximum delay for that\n  // attempt (and is, on average, the delay we will encounter).\n  // If we're not jittering, adjust baseDelay so that the first attempt\n  // lines up with initialDelay, for everyone's sanity.\n  const baseDelay = jitter ? initial : initial / 2;\n\n  return function delayFunction(count: number) {\n    let delay = Math.min(max, baseDelay * 2 ** count);\n    if (jitter) {\n      // We opt for a full jitter approach for a mostly uniform distribution,\n      // but bound it within initialDelay and delay for everyone's sanity.\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}\n","import type { GraphQLRequest, Operation } from \"../core/index.js\";\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest\n): Operation {\n  let context = { ...starting };\n  const setContext: Operation[\"setContext\"] = (next) => {\n    if (typeof next === \"function\") {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext: Operation[\"getContext\"] = () => ({ ...context });\n\n  Object.defineProperty(operation, \"setContext\", {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, \"getContext\", {\n    enumerable: false,\n    value: getContext,\n  });\n\n  return operation as Operation;\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\nexport function isSchemaCoordinateNode(node) {\n  return (\n    node.kind === Kind.TYPE_COORDINATE ||\n    node.kind === Kind.MEMBER_COORDINATE ||\n    node.kind === Kind.ARGUMENT_COORDINATE ||\n    node.kind === Kind.DIRECTIVE_COORDINATE ||\n    node.kind === Kind.DIRECTIVE_ARGUMENT_COORDINATE\n  );\n}\n","import type { VariableDefinitionNode, DocumentNode } from \"graphql\";\nimport { visit } from \"graphql\";\n\nexport function filterOperationVariables(\n  variables: Record<string, any>,\n  query: DocumentNode\n) {\n  const result = { ...variables };\n  const unusedNames = new Set(Object.keys(variables));\n  visit(query, {\n    Variable(node, _key, parent) {\n      // A variable type definition at the top level of a query is not\n      // enough to silence server-side errors about the variable being\n      // unused, so variable definitions do not count as usage.\n      // https://spec.graphql.org/draft/#sec-All-Variables-Used\n      if (\n        parent &&\n        (parent as VariableDefinitionNode).kind !== \"VariableDefinition\"\n      ) {\n        unusedNames.delete(node.name.value);\n      }\n    },\n  });\n  unusedNames.forEach((name) => {\n    delete result![name];\n  });\n  return result;\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\nimport type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\n\nimport type {\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\nimport type { NormalizedCache, NormalizedCacheObject } from \"./types.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nimport type { Policies, StorageType } from \"./policies.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n  InvalidateModifier,\n  DeleteModifier,\n  ModifierDetails,\n} from \"../core/types/common.js\";\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\n\nconst DELETE: DeleteModifier = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: InvalidateModifier = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (\n      fieldName === \"__typename\" &&\n      hasOwn.call(this.policies.rootTypenamesById, dataId)\n    ) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(\n    dataId: string,\n    dependOnExistence?: boolean\n  ): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(older: string | StoreObject, newer: StoreObject | string): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(typeof dataId === \"string\", \"store.merge expects a string ID\");\n\n    const merged: StoreObject = new DeepMerger(storeObjectReconciler).merge(\n      existing,\n      incoming\n    );\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach((storeFieldName) => {\n          if (\n            !existing ||\n            existing[storeFieldName] !== merged[storeFieldName]\n          ) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (\n              fieldName !== storeFieldName &&\n              !this.policies.hasKeyArgs(merged.__typename, fieldName)\n            ) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (\n          fieldsToDirty.__typename &&\n          !(existing && existing.__typename) &&\n          // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename\n        ) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach((fieldName) =>\n          this.group.dirty(dataId as string, fieldName)\n        );\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers<Record<string, any>>\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference\n        ) =>\n          this.policies.readField<V>(\n            typeof fieldNameOrOptions === \"string\" ?\n              {\n                fieldName: fieldNameOrOptions,\n                from: from || makeReference(dataId),\n              }\n            : fieldNameOrOptions,\n            { store: this }\n          ),\n      } satisfies Partial<ModifierDetails>;\n\n      Object.keys(storeObject).forEach((storeFieldName) => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> | undefined =\n          typeof fields === \"function\" ? fields : (\n            fields[storeFieldName] || fields[fieldName]\n          );\n        if (modify) {\n          let newValue =\n            modify === delModifier ? DELETE : (\n              modify(maybeDeepFreeze(fieldValue), {\n                ...sharedDetails,\n                fieldName,\n                storeFieldName,\n                storage: this.getStorage(dataId, storeFieldName),\n              })\n            );\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue as StoreValue;\n\n              if (__DEV__) {\n                const checkReference = (ref: Reference) => {\n                  if (this.lookup(ref.__ref) === undefined) {\n                    invariant.warn(\n                      \"cache.modify: You are trying to write a Reference that is not part of the store: %o\\n\" +\n                        \"Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\\n\" +\n                        \"`toReference(object, true)`\",\n                      ref\n                    );\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  let seenReference: boolean = false;\n                  let someNonReference: unknown;\n                  for (const value of newValue) {\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        const [id] = this.policies.identify(value);\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      invariant.warn(\n                        \"cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\\n\" +\n                          \"Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`.\",\n                        someNonReference\n                      );\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName =\n        fieldName && args ?\n          this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(\n        dataId,\n        storeFieldName ?\n          {\n            [storeFieldName]: delModifier,\n          }\n        : delModifier\n      );\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions, limit: EntityStore): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach((id) => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach((dataId) => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach((dataId) => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach((id) => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach((id) => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = (this.refs[dataId] = Object.create(null));\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach((obj) => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach((key) => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  /** overload for `InMemoryCache.maybeBroadcastWatch` */\n  public makeCacheKey(\n    document: DocumentNode,\n    callback: Cache.WatchCallback<any>,\n    details: string\n  ): object;\n  /** overload for `StoreReader.executeSelectionSet` */\n  public makeCacheKey(\n    selectionSet: SelectionSetNode,\n    parent: string /* = ( Reference.__ref ) */ | StoreObject,\n    varString: string | undefined,\n    canonizeResults: boolean\n  ): object;\n  /** overload for `StoreReader.executeSubSelectedArray` */\n  public makeCacheKey(\n    field: FieldNode,\n    array: readonly any[],\n    varString: string | undefined\n  ): object;\n  /** @deprecated This is only meant for internal usage,\n   * in your own code please use a `Trie` instance instead. */\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string\n  ) =>\n    maybeDeepFreeze(\n      isReference(objectOrReference) ?\n        this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n    ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = (objOrRef) => {\n    return isReference(objOrRef) ?\n        this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (objOrIdOrRef, mergeIntoStore) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker!: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach((dataId) => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach((storeFieldName) => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach((storeFieldName) => {\n              if (\n                !equal(\n                  ownStoreObject[storeFieldName],\n                  parentStoreObject[storeFieldName]\n                )\n              ) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ?\n        {\n          ...fromParent,\n          ...super.findChildRefIds(dataId),\n        }\n      : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(\n      p,\n      // @ts-expect-error\n      arguments\n    );\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group)\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge(older: string | StoreObject, newer: string | StoreObject) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string | number\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport type * as ReactTypes from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: ReactTypes.ReactNode | ReactTypes.ReactNode[] | null;\n}\n\nexport const ApolloProvider: ReactTypes.FC<ApolloProviderProps<any>> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  canonicalStringify,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen =\n      context.canonizeResults ?\n        this.canon.admit(finalResult)\n        // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n","import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform } from \"../utilities/index.js\";\nimport type { Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n  InteropApolloQueryResult,\n  InteropMutateResult,\n  InteropSubscribeResult,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nexport interface DevtoolsOptions {\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n   *\n   * The default value is `false` in production and `true` in development if there is a `window` object.\n   */\n  enabled?: boolean;\n\n  /**\n   * Optional name for this `ApolloClient` instance in the devtools. This is\n   * useful when you instantiate multiple clients and want to be able to\n   * identify them by name.\n   */\n  name?: string;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   *\n   * @deprecated `uri` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `uri` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ uri })\n   * });\n   * ```\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * @deprecated `credentials` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `credentials` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ credentials })\n   * });\n   * ```\n   */\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   *\n   * @deprecated `headers` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `headers` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ headers })\n   * });\n   * ```\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   *\n   * @deprecated `connectToDevTools` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use the `devtools.enabled` option instead.\n   *\n   * ```ts\n   * new ApolloClient({\n   *   devtools: { enabled: true }\n   * });\n   * ```\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n\n  /**\n   * @deprecated `resolvers` has been moved in Apollo Client 4.0. This option is\n   * safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `resolvers` will need to be passed as the `resolvers` option to an instance\n   * of `LocalState`. That `LocalState` instance should be provided as the\n   * `localState` option to the `ApolloClient` constructor.\n   */\n  resolvers?: Resolvers | Resolvers[];\n\n  /**\n   * @deprecated `typeDefs` will be removed in Apollo Client 4.0. It is safe to\n   * stop using this option in Apollo Client 3.x.\n   */\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n\n  /**\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using this in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. This\n   * option should then be removed. If working with a 3rd party cache\n   * implementation, ensure the 3rd party cache implements the\n   * `cache.fragmentMatches` method.\n   */\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.name` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.name` to set the client awareness name.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { name } });\n   * ```\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.version` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.version` to set the client awareness version.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { version } });\n   * ```\n   */\n  version?: string;\n\n  clientAwareness?: {\n    /**\n     * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     */\n    name?: string;\n    /**\n     * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     *\n     * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n     */\n    version?: string;\n  };\n\n  documentTransform?: DocumentTransform;\n\n  /**\n   * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n   *\n   * @since 3.11.0\n   */\n  devtools?: DevtoolsOptions;\n\n  /**\n   * Determines if data masking is enabled for the client.\n   *\n   * @defaultValue false\n   */\n  dataMasking?: boolean;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nimport { warnRemovedOption } from \"../utilities/deprecation/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape = any> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n\n  /**\n   * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`\n   * in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Access `client.prioritizeCacheValues` instead.\n   */\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n  public readonly devtoolsConfig: DevtoolsOptions;\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  public localState: LocalState<TCacheShape>;\n\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  public get prioritizeCacheValues() {\n    return this.disableNetworkFetches;\n  }\n\n  public set prioritizeCacheValues(value: boolean) {\n    this.disableNetworkFetches = value;\n  }\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      clientAwareness,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n      devtools,\n      dataMasking,\n    } = options;\n\n    if (__DEV__) {\n      warnRemovedOption(\n        options,\n        \"connectToDevTools\",\n        \"ApolloClient\",\n        \"Please use `devtools.enabled` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"uri\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `uri` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"credentials\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `credentials` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"headers\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `headers` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"name\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.name` option instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"version\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.version` option instead.\"\n      );\n      warnRemovedOption(options, \"typeDefs\", \"ApolloClient\");\n\n      if (!options.link) {\n        invariant.warn(\n          \"[ApolloClient]: Apollo Client 4.0 will require a `link` option and will not create a default link when not provided. Please provide a `link` option.\"\n        );\n      }\n    }\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? connectToDevTools,\n    };\n\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = __DEV__;\n    }\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwareness?.name ?? clientAwarenessName!,\n        version: clientAwareness?.version ?? clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient<any>): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient<any>;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.watchQuery\");\n      warnRemovedOption(options, \"partialRefetch\", \"client.watchQuery\");\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: QueryOptions<TVariables, T>\n  ): Promise<InteropApolloQueryResult<MaybeMasked<T>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.query\");\n      warnRemovedOption(\n        options,\n        \"notifyOnNetworkStatusChange\",\n        \"client.query\",\n        \"This option does not affect `client.query` and can be safely removed.\"\n      );\n\n      if (options.fetchPolicy === \"standby\") {\n        invariant.warn(\n          \"[client.query]: Apollo Client 4.0 will no longer support the `standby` fetch policy with `client.query`. Please use a different fetch policy.\"\n        );\n      }\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<InteropMutateResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: SubscriptionOptions<TVariables, T>\n  ): Observable<InteropSubscribeResult<MaybeMasked<T>>> {\n    const id = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .startGraphQLSubscription<T>(options)\n      .map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id,\n        }),\n      }));\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment({\n      ...options,\n      [Symbol.for(\"apollo.dataMasking\")]: this.queryManager.dataMasking,\n    });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    payload: GraphQLRequest\n  ): Observable<FormattedExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<InteropApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<InteropApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<InteropApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   *\n   * @deprecated `addResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Use `client.localState.addResolvers(resolvers)`. Alternatively, store\n   * the `LocalState` instance in a separate variable and call `addResolvers` on\n   * that.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   *\n   * @deprecated `setResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `setResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `setResolvers`.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   *\n   * @deprecated `getResolvers` will be removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `getResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `getResolvers`.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   *\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using `setLocalStateFragmentMatcher` in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. If working\n   * with a 3rd party cache implementation, ensure the 3rd party cache implements\n   * the `cache.fragmentMatches` method. This function should no longer be used.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from \"graphql\";\n\nimport type {\n  FragmentMap,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from \"../../utilities/index.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from \"../core/types/common.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\ntype InternalFieldPolicy = {\n  typename: string;\n  keyFn?: KeyArgsFunction;\n  read?: FieldReadFunction<any>;\n  merge?: FieldMergeFunction<any>;\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: InternalFieldPolicy;\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> =\n    Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> =\n    Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        function () {\n          const options = normalizeReadFieldOptions(arguments, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(\n    typename: string,\n    incoming: TypePolicy,\n    existingFieldPolicies: Record<string, InternalFieldPolicy>\n  ) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        let existing = existingFieldPolicies[fieldName] as\n          | InternalFieldPolicy\n          | undefined;\n        // Field policy inheritance is atomic/shallow: you can't inherit a\n        // field policy and then override just its read function, since read\n        // and merge functions often need to cooperate, so changing only one\n        // of them would be a recipe for inconsistency.\n        // So here we avoid merging an inherited field policy with an updated one.\n        if (!existing || existing?.typename !== typename) {\n          existing = existingFieldPolicies[fieldName] = { typename };\n        }\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = Object.create(null));\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(\n          typename,\n          policy,\n          this.typePolicies[typename].fields\n        );\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string\n  ): InternalFieldPolicy | undefined {\n    if (typename) {\n      return this.getTypePolicy(typename).fields[fieldName];\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || Object.create(null)\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      if (__DEV__) {\n        invariant.warn(\n          \"[HttpLink]: Apollo Client 4.0 will no longer remove `@client` fields from queries sent through the link chain. Please open an issue if this warning is displayed under standard usage.\"\n        );\n      }\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n","import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n","import type { DocumentNode, GraphQLFormattedError } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport type { WatchQueryOptions, ErrorPolicy } from \"./watchQueryOptions.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport {\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from \"../utilities/index.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type { Unmasked } from \"../masking/index.js\";\nimport { muteDeprecations } from \"../utilities/deprecation/index.js\";\n\nexport type QueryStoreValue = Pick<\n  QueryInfo,\n  \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\"\n>;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\nconst destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)<\n  ApolloCache<any>,\n  number\n>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: \"evict\" | \"modify\" | \"reset\"\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  stopped = false;\n\n  private cancelWatch?: () => void;\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId()\n  ) {\n    const cache = (this.cache = queryManager.cache);\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined;\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus;\n    observableQuery?: ObservableQuery<any, any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (\n      this.variables &&\n      this.networkStatus !== NetworkStatus.loading &&\n      !equal(this.variables, query.variables)\n    ) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n      // Ensure we don't continue to receive cache updates for old variables\n      this.cancel();\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  resetDiff() {\n    this.lastDiff = void 0;\n  }\n\n  getDiff(): Cache.DiffResult<any> {\n    const options = this.getDiffOptions();\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = muteDeprecations(\"canonizeResults\", () =>\n      this.cache.diff(options)\n    );\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>;\n    options: Cache.DiffOptions;\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions\n  ) {\n    this.lastDiff =\n      diff ?\n        {\n          diff,\n          options: options || this.getDiffOptions(),\n        }\n      : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (\n      diff &&\n      !diff.complete &&\n      muteDeprecations(\n        \"getLastError\",\n        () => this.observableQuery?.getLastError()\n      )\n    ) {\n      return;\n    }\n\n    this.updateLastDiff(diff);\n\n    if (!equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.observableQuery?.[\"scheduleNotify\"]();\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any, any> | null = null;\n  setObservableQuery(oq: ObservableQuery<any, any> | null) {\n    if (oq === this.observableQuery) return;\n    (this as any).observableQuery = oq;\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n    }\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.observableQuery?.[\"resetNotifications\"]();\n      this.cancel();\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  private cancel() {\n    this.cancelWatch?.();\n    this.cancelWatch = void 0;\n  }\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: (diff) => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancelWatch = this.cache.watch((this.lastWatch = watchOptions));\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<\n      WatchQueryOptions,\n      \"variables\" | \"fetchPolicy\" | \"errorPolicy\"\n    >,\n    cacheWriteBehavior: CacheWriteBehavior\n  ) {\n    const merger = new DeepMerger();\n    const graphQLErrors =\n      isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.observableQuery?.[\"resetNotifications\"]();\n\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      const mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      const diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables)\n      );\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction((cache) => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as Unmasked<T>,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff && this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = muteDeprecations(\"canonizeResults\", () =>\n            cache.diff<T>(diffOptions)\n          );\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!this.stopped && equal(this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return (this.networkStatus = NetworkStatus.ready);\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.observableQuery?.[\"resetNotifications\"]();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n","import { Trie } from \"@wry/trie\";\nimport {\n  canUseWeakMap,\n  canUseWeakSet,\n  isNonNullObject as isObjectOrArray,\n} from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\n\nfunction shallowCopy<T>(value: T): T {\n  if (isObjectOrArray(value)) {\n    return isArray(value) ?\n        (value.slice(0) as any as T)\n      : { __proto__: Object.getPrototypeOf(value), ...value };\n  }\n  return value;\n}\n\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nexport class ObjectCanon {\n  // Set of all canonical objects this ObjectCanon has admitted, allowing\n  // canon.admit to return previously-canonicalized objects immediately.\n  private known = new (canUseWeakSet ? WeakSet : Set)<object>();\n\n  // Efficient storage/lookup structure for canonical objects.\n  private pool = new Trie<{\n    array?: any[];\n    object?: Record<string, any>;\n    keys?: SortedKeysInfo;\n  }>(canUseWeakMap);\n\n  public isKnown(value: any): boolean {\n    return isObjectOrArray(value) && this.known.has(value);\n  }\n\n  // Make the ObjectCanon assume this value has already been\n  // canonicalized.\n  private passes = new WeakMap<object, object>();\n  public pass<T>(value: T): T;\n  public pass(value: any) {\n    if (isObjectOrArray(value)) {\n      const copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  }\n\n  // Returns the canonical version of value.\n  public admit<T>(value: T): T;\n  public admit(value: any) {\n    if (isObjectOrArray(value)) {\n      const original = this.passes.get(value);\n      if (original) return original;\n\n      const proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype: {\n          if (this.known.has(value)) return value;\n          const array: any[] = (value as any[]).map(this.admit, this);\n          // Arrays are looked up in the Trie using their recursively\n          // canonicalized elements, and the known version of the array is\n          // preserved as node.array.\n          const node = this.pool.lookupArray(array);\n          if (!node.array) {\n            this.known.add((node.array = array));\n            // Since canonical arrays may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(array);\n            }\n          }\n          return node.array;\n        }\n\n        case null:\n        case Object.prototype: {\n          if (this.known.has(value)) return value;\n          const proto = Object.getPrototypeOf(value);\n          const array = [proto];\n          const keys = this.sortedKeys(value);\n          array.push(keys.json);\n          const firstValueIndex = array.length;\n          keys.sorted.forEach((key) => {\n            array.push(this.admit((value as any)[key]));\n          });\n          // Objects are looked up in the Trie by their prototype (which\n          // is *not* recursively canonicalized), followed by a JSON\n          // representation of their (sorted) keys, followed by the\n          // sequence of recursively canonicalized values corresponding to\n          // those keys. To keep the final results unambiguous with other\n          // sequences (such as arrays that just happen to contain [proto,\n          // keys.json, value1, value2, ...]), the known version of the\n          // object is stored as node.object.\n          const node = this.pool.lookupArray(array);\n          if (!node.object) {\n            const obj = (node.object = Object.create(proto));\n            this.known.add(obj);\n            keys.sorted.forEach((key, i) => {\n              obj[key] = array[firstValueIndex + i];\n            });\n            // Since canonical objects may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(obj);\n            }\n          }\n          return node.object;\n        }\n      }\n    }\n    return value;\n  }\n\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  private sortedKeys(obj: object) {\n    const keys = Object.keys(obj);\n    const node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      const json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, (node.keys = { sorted: keys, json }));\n      }\n    }\n    return node.keys;\n  }\n  // Arrays that contain the same elements in a different order can share\n  // the same SortedKeysInfo object, to save memory.\n  private keysByJSON = new Map<string, SortedKeysInfo>();\n\n  // This has to come last because it depends on keysByJSON.\n  public readonly empty = this.admit({});\n}\n\ntype SortedKeysInfo = {\n  sorted: string[];\n  json: string;\n};\n","import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  addNonReactiveToNamedFragments,\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  isFullyUnmaskedOperation,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport type { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nimport { muteDeprecations } from \"../utilities/deprecation/index.js\";\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  id: string;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport interface QueryManagerOptions<TStore> {\n  cache: ApolloCache<TStore>;\n  link: ApolloLink;\n  defaultOptions: DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  clientAwareness: Record<string, string>;\n  localState: LocalState<TStore>;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions<TStore>) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<MaybeMasked<TData>>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          {},\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(\n              storeResult as FetchResult<Unmasked<TData>>\n            );\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve({\n              ...storeResult,\n              data: self.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                id: mutationId,\n              }) as any,\n            });\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result as FetchResult<Unmasked<TData>>,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result as FetchResult<Unmasked<TData>>, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(\n      this.getOrCreateQuery(queryId),\n      options,\n      networkStatus\n    ).concast.promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n      this.queries.set(observable.queryId, queryInfo);\n    }\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVars>(queryId, { ...options, query })\n      .then(\n        (result) =>\n          result && {\n            ...result,\n            data: this.maskOperation({\n              document: query,\n              data: result.data,\n              fetchPolicy: options.fetchPolicy,\n              id: queryId,\n            }),\n          }\n      )\n      .finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNames = new Map<string, string | null>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n          (document && queryNamesAndQueryStrings.has(print(document)))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getOrCreateQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        muteDeprecations(\"resetLastResults\", () =>\n          observableQuery.resetLastResults()\n        );\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        (this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(\n          null\n        );\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions\n  ): Observable<FetchResult<T>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables, extensions).map(\n        (result) => {\n          if (fetchPolicy !== \"no-cache\") {\n            // the subscription interface should handle not sending us results we no longer subscribe to.\n            // XXX I don't think we ever send in an object with errors, but we might in the future...\n            if (shouldWriteResult(result, errorPolicy)) {\n              this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables,\n              });\n            }\n\n            this.broadcastQueries();\n          }\n\n          const hasErrors = graphQLResultHasError(result);\n          const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            const errors: ApolloErrorOptions = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            // `errorPolicy` is a mechanism for handling GraphQL errors, according\n            // to our documentation, so we throw protocol errors regardless of the\n            // set error policy.\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n\n          return result;\n        }\n      );\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.queries.get(queryId)?.stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.observableQuery?.[\"notify\"]());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n        extensions,\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(function cb(method, arg: FetchResult) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast.beforeNext(cb);\n            } else {\n              inFlightLinkObservables.remove(printedServerQuery, varJson);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n        const { errorPolicy } = options;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors && errorPolicy === \"none\") {\n          aqr.data = void 0 as TData;\n        }\n\n        if (hasErrors && errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryInfo.queryId);\n    this.fetchCancelFns.set(queryInfo.queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: (this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = muteDeprecations(\"canonizeResults\", () =>\n              this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]())\n            );\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByQueryId = new Set<string>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, id } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      const operationId = (operationType?.[0] ?? \"o\") + id;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByQueryId.has(operationId)\n      ) {\n        this.noCacheWarningsByQueryId.add(operationId);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document) ??\n            `Unnamed ${operationType ?? \"operation\"}`\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  public getOrCreateQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n","import { invariant } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  ASTNode,\n  ASTVisitFn,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { visit, Kind } from \"graphql\";\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\n\n// https://github.com/graphql/graphql-js/blob/8d7c8fccf5a9846a50785de04abda58a7eb13fc0/src/language/visitor.ts#L20-L23\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig =\n  RemoveNodeConfig<FragmentDefinitionNode>;\nexport type RemoveVariableDefinitionConfig =\n  RemoveNodeConfig<VariableDefinitionNode>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return (\n      isEmpty(\n        getOperationDefinition(doc) || getFragmentDefinition(doc),\n        createFragmentMap(getFragmentDefinitions(doc))\n      )\n    ) ?\n      null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: EnterLeaveVisitor<\n    FieldNode | InlineFragmentNode\n  > = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: EnterLeaveVisitor<\n    FragmentSpreadNode | FragmentDefinitionNode\n  > = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              isField(selection) &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            isField(field) &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some((arg) => arg.name.value === \"key\")\n      ) {\n        invariant.warn(\n          \"Removing an @connection directive even though it does not have a key. \" +\n            \"You may want to use the key parameter to specify a store key.\"\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc)\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some((selection) =>\n      hasDirectivesInSelection(directives, selection, nestedCheck)\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument)))\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions:\n              node.variableDefinitions ?\n                node.variableDefinitions.filter(\n                  (varDef) =>\n                    !config.some(\n                      (arg) => arg.name === varDef.variable.name.value\n                    )\n                )\n              : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(\n            (argConfig) => argConfig.remove\n          );\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach((arg) => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    })\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode\n  ): null | void {\n    if (config.some((def) => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    })\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: \"query\",\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === \"client\",\n        remove: true,\n      },\n    ],\n    document\n  );\n\n  return modifiedDoc;\n}\n\nexport function addNonReactiveToNamedFragments(document: DocumentNode) {\n  checkDocument(document);\n\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n","/**\n * Prints a string as a GraphQL StringValue literal. Replaces control characters\n * and excluded characters (\" U+0022 and \\\\ U+005C) with escape sequences.\n */\nexport function printString(str) {\n  return `\"${str.replace(escapedRegExp, escapedReplacer)}\"`;\n} // eslint-disable-next-line no-control-regex\n\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\n\nfunction escapedReplacer(str) {\n  return escapeSequences[str.charCodeAt(0)];\n} // prettier-ignore\n\nconst escapeSequences = [\n  '\\\\u0000',\n  '\\\\u0001',\n  '\\\\u0002',\n  '\\\\u0003',\n  '\\\\u0004',\n  '\\\\u0005',\n  '\\\\u0006',\n  '\\\\u0007',\n  '\\\\b',\n  '\\\\t',\n  '\\\\n',\n  '\\\\u000B',\n  '\\\\f',\n  '\\\\r',\n  '\\\\u000E',\n  '\\\\u000F',\n  '\\\\u0010',\n  '\\\\u0011',\n  '\\\\u0012',\n  '\\\\u0013',\n  '\\\\u0014',\n  '\\\\u0015',\n  '\\\\u0016',\n  '\\\\u0017',\n  '\\\\u0018',\n  '\\\\u0019',\n  '\\\\u001A',\n  '\\\\u001B',\n  '\\\\u001C',\n  '\\\\u001D',\n  '\\\\u001E',\n  '\\\\u001F',\n  '',\n  '',\n  '\\\\\"',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 2F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 3F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 4F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '\\\\\\\\',\n  '',\n  '',\n  '', // 5F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 6F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '\\\\u007F',\n  '\\\\u0080',\n  '\\\\u0081',\n  '\\\\u0082',\n  '\\\\u0083',\n  '\\\\u0084',\n  '\\\\u0085',\n  '\\\\u0086',\n  '\\\\u0087',\n  '\\\\u0088',\n  '\\\\u0089',\n  '\\\\u008A',\n  '\\\\u008B',\n  '\\\\u008C',\n  '\\\\u008D',\n  '\\\\u008E',\n  '\\\\u008F',\n  '\\\\u0090',\n  '\\\\u0091',\n  '\\\\u0092',\n  '\\\\u0093',\n  '\\\\u0094',\n  '\\\\u0095',\n  '\\\\u0096',\n  '\\\\u0097',\n  '\\\\u0098',\n  '\\\\u0099',\n  '\\\\u009A',\n  '\\\\u009B',\n  '\\\\u009C',\n  '\\\\u009D',\n  '\\\\u009E',\n  '\\\\u009F',\n];\n","import type { Operation, FetchResult, NextLink } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type { DelayFunction, DelayFunctionOptions } from \"./delayFunction.js\";\nimport { buildDelayFunction } from \"./delayFunction.js\";\nimport type { RetryFunction, RetryFunctionOptions } from \"./retryFunction.js\";\nimport { buildRetryFunction } from \"./retryFunction.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\nimport {\n  ApolloError,\n  graphQLResultHasProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n} from \"../../errors/index.js\";\n\nexport namespace RetryLink {\n  export interface Options {\n    /**\n     * Configuration for the delay strategy to use, or a custom delay strategy.\n     */\n    delay?: DelayFunctionOptions | DelayFunction;\n\n    /**\n     * Configuration for the retry strategy to use, or a custom retry strategy.\n     */\n    attempts?: RetryFunctionOptions | RetryFunction;\n  }\n}\n\n/**\n * Tracking and management of operations that may be (or currently are) retried.\n */\nclass RetryableOperation {\n  private retryCount: number = 0;\n  private currentSubscription: ObservableSubscription | null = null;\n  private timerId: number | undefined;\n\n  constructor(\n    private observer: SubscriptionObserver<FetchResult>,\n    private operation: Operation,\n    private forward: NextLink,\n    private delayFor: DelayFunction,\n    private retryIf: RetryFunction\n  ) {\n    this.try();\n  }\n\n  /**\n   * Stop retrying for the operation, and cancel any in-progress requests.\n   */\n  public cancel() {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n    }\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n    this.currentSubscription = null;\n  }\n\n  private try() {\n    this.currentSubscription = this.forward(this.operation).subscribe({\n      next: (result) => {\n        if (graphQLResultHasProtocolErrors(result)) {\n          this.onError(\n            new ApolloError({\n              protocolErrors: result.extensions[PROTOCOL_ERRORS_SYMBOL],\n            })\n          );\n          // Unsubscribe from the current subscription to prevent the `complete`\n          // handler to be called as a result of the stream closing.\n          this.currentSubscription?.unsubscribe();\n          return;\n        }\n\n        this.observer.next(result);\n      },\n      error: this.onError,\n      complete: this.observer.complete.bind(this.observer),\n    });\n  }\n\n  private onError = async (error: any) => {\n    this.retryCount += 1;\n\n    // Should we retry?\n    const shouldRetry = await this.retryIf(\n      this.retryCount,\n      this.operation,\n      error\n    );\n    if (shouldRetry) {\n      this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n      return;\n    }\n\n    this.observer.error(error);\n  };\n\n  private scheduleRetry(delay: number) {\n    if (this.timerId) {\n      throw new Error(`RetryLink BUG! Encountered overlapping retries`);\n    }\n\n    this.timerId = setTimeout(() => {\n      this.timerId = undefined;\n      this.try();\n    }, delay) as any as number;\n  }\n}\n\nexport class RetryLink extends ApolloLink {\n  private delayFor: DelayFunction;\n  private retryIf: RetryFunction;\n\n  constructor(options?: RetryLink.Options) {\n    super();\n    const { attempts, delay } = options || ({} as RetryLink.Options);\n    this.delayFor =\n      typeof delay === \"function\" ? delay : buildDelayFunction(delay);\n    this.retryIf =\n      typeof attempts === \"function\" ? attempts : buildRetryFunction(attempts);\n  }\n\n  public request(\n    operation: Operation,\n    nextLink: NextLink\n  ): Observable<FetchResult> {\n    return new Observable((observer) => {\n      const retryable = new RetryableOperation(\n        observer,\n        operation,\n        nextLink,\n        this.delayFor,\n        this.retryIf\n      );\n      return () => {\n        retryable.cancel();\n      };\n    });\n  }\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n","import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  StoreObject,\n  Reference,\n  DeepPartial,\n  NoInfer,\n} from \"../../utilities/index.js\";\nimport {\n  Observable,\n  cacheSizes,\n  defaultCacheSizes,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n  mergeDeepArray,\n} from \"../../utilities/index.js\";\nimport type { DataProxy } from \"./types/DataProxy.js\";\nimport type { Cache } from \"./types/Cache.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport type {\n  OperationVariables,\n  TypedDocumentNode,\n} from \"../../core/types.js\";\nimport type { MissingTree } from \"./types/common.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { maskFragment } from \"../../masking/index.js\";\nimport type {\n  FragmentType,\n  MaybeMasked,\n  Unmasked,\n} from \"../../masking/index.js\";\nimport {\n  muteDeprecations,\n  warnRemovedOption,\n} from \"../../utilities/deprecation/index.js\";\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\n/**\n * Watched fragment options.\n */\nexport interface WatchFragmentOptions<TData, TVars> {\n  /**\n   * A GraphQL fragment document parsed into an AST with the `gql`\n   * template literal.\n   *\n   * @docGroup 1. Required options\n   */\n  fragment: DocumentNode | TypedDocumentNode<TData, TVars>;\n  /**\n   * An object containing a `__typename` and primary key fields\n   * (such as `id`) identifying the entity object from which the fragment will\n   * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n   * (uncommon).\n   *\n   * @docGroup 1. Required options\n   */\n  from: StoreObject | Reference | FragmentType<NoInfer<TData>> | string;\n  /**\n   * Any variables that the GraphQL fragment may depend on.\n   *\n   * @docGroup 2. Cache options\n   */\n  variables?: TVars;\n  /**\n   * The name of the fragment defined in the fragment document.\n   *\n   * Required if the fragment document includes more than one fragment,\n   * optional otherwise.\n   *\n   * @docGroup 2. Cache options\n   */\n  fragmentName?: string;\n  /**\n   * If `true`, `watchFragment` returns optimistic results.\n   *\n   * The default value is `true`.\n   *\n   * @docGroup 2. Cache options\n   */\n  optimistic?: boolean;\n}\n\n/**\n * Watched fragment results.\n */\nexport type WatchFragmentResult<TData> =\n  | {\n      data: MaybeMasked<TData>;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<MaybeMasked<TData>>;\n      complete: false;\n      missing: MissingTree;\n    };\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<TData = any, TVariables = any>(\n    query: Cache.ReadOptions<TVariables, TData>\n  ): Unmasked<TData> | null;\n  public abstract write<TData = any, TVariables = any>(\n    write: Cache.WriteOptions<TData, TVariables>\n  ): Reference | undefined;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Data masking API\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public fragmentMatches?(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  // DataProxy API\n  public readQuery<QueryType, TVariables = any>(\n    options: Cache.ReadQueryOptions<QueryType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<QueryType> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.readQuery\");\n    }\n\n    return muteDeprecations(\"canonizeResults\", () =>\n      this.read({\n        ...options,\n        rootId: options.id || \"ROOT_QUERY\",\n        optimistic,\n      })\n    );\n  }\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<TData = any, TVars = OperationVariables>(\n    options: WatchFragmentOptions<TData, TVars>\n  ): Observable<WatchFragmentResult<TData>> {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id =\n      typeof from === \"undefined\" || typeof from === \"string\" ?\n        from\n      : this.identify(from);\n    const dataMasking = !!(options as any)[Symbol.for(\"apollo.dataMasking\")];\n\n    if (__DEV__) {\n      const actualFragmentName =\n        fragmentName || getFragmentDefinition(fragment).name.value;\n\n      if (!id) {\n        invariant.warn(\n          \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n          actualFragmentName\n        );\n      }\n    }\n\n    const diffOptions: Cache.DiffOptions<TData, TVars> = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic,\n    };\n\n    let latestDiff: DataProxy.DiffResult<TData> | undefined;\n\n    return new Observable((observer) => {\n      return this.watch<TData, TVars>({\n        ...diffOptions,\n        immediate: true,\n        callback: (diff) => {\n          const data =\n            dataMasking ?\n              maskFragment(diff.result, fragment, this, fragmentName)\n            : diff.result;\n\n          if (\n            // Always ensure we deliver the first result\n            latestDiff &&\n            equalByQuery(\n              query,\n              { data: latestDiff.result },\n              { data },\n              // TODO: Fix the type on WatchFragmentOptions so that TVars\n              // extends OperationVariables\n              options.variables as OperationVariables\n            )\n          ) {\n            return;\n          }\n\n          const result = {\n            data,\n            complete: !!diff.complete,\n          } as WatchFragmentResult<TData>;\n\n          if (diff.missing) {\n            result.missing = mergeDeepArray(\n              diff.missing.map((error) => error.missing)\n            );\n          }\n\n          latestDiff = { ...diff, result: data };\n          observer.next(result);\n        },\n      });\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n  });\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: Cache.ReadFragmentOptions<FragmentType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<FragmentType> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.readFragment\");\n    }\n\n    return muteDeprecations(\"canonizeResults\", () =>\n      this.read({\n        ...options,\n        query: this.getFragmentDoc(options.fragment, options.fragmentName),\n        rootId: options.id,\n        optimistic,\n      })\n    );\n  }\n\n  public writeQuery<TData = any, TVariables = any>({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  public writeFragment<TData = any, TVariables = any>({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<TData = any, TVariables = any>(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.updateQuery\");\n    }\n\n    return this.batch({\n      update(cache) {\n        const value = muteDeprecations(\"canonizeResults\", () =>\n          cache.readQuery<TData, TVariables>(options)\n        );\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<TData = any, TVariables = any>(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.updateFragment\");\n    }\n\n    return this.batch({\n      update(cache) {\n        const value = muteDeprecations(\"canonizeResults\", () =>\n          cache.readFragment<TData, TVariables>(options)\n        );\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type { SelectionSetNode, FieldNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n  canonicalStringify,\n} from \"../../utilities/index.js\";\n\nimport type {\n  NormalizedCache,\n  ReadMergeModifyContext,\n  MergeTree,\n  InMemoryCacheConfig,\n} from \"./types.js\";\nimport {\n  isArray,\n  makeProcessedFieldsMerger,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  extractFragmentContext,\n} from \"./helpers.js\";\nimport type { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { EntityStore } from \"./entityStore.js\";\nimport type { Cache } from \"../../core/index.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nimport type { ReadFieldFunction } from \"../core/types/common.js\";\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<\n    string,\n    {\n      storeObject: StoreObject;\n      mergeTree?: MergeTree;\n      fieldNodeSet: Set<FieldNode>;\n    }\n  >;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n}\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  \"clientOnly\" | \"deferred\" | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"]\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(\n      key,\n      (flavored =\n        context.clientOnly === clientOnly && context.deferred === deferred ?\n          context\n        : {\n            ...context,\n            clientOnly,\n            deferred,\n          })\n    );\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string;\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"]\n  ) {}\n\n  public writeToStore(\n    store: NormalizedCache,\n    { query, result, dataId, variables, overwrite }: Cache.WriteOptions\n  ): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map(),\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map() },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw newInvariantError(`Could not identify object %s`, result);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(\n      ({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n        const entityRef = makeReference(dataId);\n\n        if (mergeTree && mergeTree.map.size) {\n          const applied = this.applyMerges(\n            mergeTree,\n            entityRef,\n            storeObject,\n            context\n          );\n          if (isReference(applied)) {\n            // Assume References returned by applyMerges have already been merged\n            // into the store. See makeMergeObjectsFunction in policies.ts for an\n            // example of how this can happen.\n            return;\n          }\n          // Otherwise, applyMerges returned a StoreObject, whose fields we should\n          // merge into the store (see store.merge statement below).\n          storeObject = applied;\n        }\n\n        if (__DEV__ && !context.overwrite) {\n          const fieldsWithSelectionSets: Record<string, true> =\n            Object.create(null);\n          fieldNodeSet.forEach((field) => {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets[field.name.value] = true;\n            }\n          });\n\n          const hasSelectionSet = (storeFieldName: string) =>\n            fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n            true;\n\n          const hasMergeFunction = (storeFieldName: string) => {\n            const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n\n          Object.keys(storeObject).forEach((storeFieldName) => {\n            // If a merge function was defined for this field, trust that it\n            // did the right thing about (not) clobbering data. If the field\n            // has no selection set, it's a scalar field, so it doesn't need\n            // a merge function (even if it's an object, like JSON data).\n            if (\n              hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)\n            ) {\n              warnAboutDataLoss(\n                entityRef,\n                storeObject,\n                storeFieldName,\n                context.store\n              );\n            }\n          });\n        }\n\n        store.merge(dataId, storeObject);\n      }\n    );\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && (context.store.get(dataId, \"__typename\") as string));\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField(\n            {\n              ...options,\n              from: info.storeObject,\n            },\n            context\n          );\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet ?\n            getContextFlavor(context, false, false)\n          : context,\n          childTree\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (\n          field.selectionSet &&\n          (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))\n        ) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(\n          `Missing field '%s' while writing result %o`,\n          resultKeyNameFromField(field),\n          result\n        );\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (\n        this.reader &&\n        this.reader.isFresh(result, dataRef, selectionSet, context)\n      ) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item,\n          field,\n          context,\n          getChildMergeTree(mergeTree, i)\n        );\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<\n    TContext extends Pick<\n      WriteContext,\n      | \"clientOnly\"\n      | \"deferred\"\n      | \"flavors\"\n      | \"fragmentMap\"\n      | \"lookupFragment\"\n      | \"variables\"\n    >,\n  >(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach((selection) => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach((dir) => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred)\n          );\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(\n              `No fragment named %s`,\n              selection.name.value\n            );\n          }\n\n          if (\n            fragment &&\n            policies.fragmentMatches(\n              fragment,\n              typename,\n              result,\n              context.variables\n            )\n          ) {\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred)\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined =\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        (\n          !isArray(incoming) &&\n          // Likewise, existing must be either a Reference or a StoreObject\n          // in order for its fields to be safe to merge with the fields of\n          // the incoming object.\n          (isReference(existing) || storeValueIsStoreObject(existing))\n        ) ?\n          existing\n        : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number\n      ): StoreValue => {\n        return (\n          isArray(from) ?\n            typeof name === \"number\" ?\n              from[name]\n            : void 0\n          : context.store.getFieldValue(from, String(name))\n        );\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map();\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs)\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info =\n    left.info && right.info ?\n      {\n        ...left.info,\n        ...right.info,\n      }\n    : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map =\n    needToMergeMaps ? new Map()\n    : left.map.size ? left.map\n    : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach((key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(right.map.get(key), left.map.get(key))\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree({ map }: MergeTree, name: string | number) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (\n    Object.keys(existing).every(\n      (key) => store.getFieldValue(incoming, key) !== void 0\n    )\n  ) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach((child) => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n    `Cache data may be lost when replacing the %s field of a %s object.\n\nThis could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.\n\nTo address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:\n\n  existing: %o\n  incoming: %o\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`,\n    fieldName,\n    parentType,\n    childTypenames.length ?\n      \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") +\n        \" have an ID or a custom merge function, or \"\n    : \"\",\n    typeDotName,\n    { ...existing },\n    { ...incoming }\n  );\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n","import { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\n\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport {\n  addTypenameToDocument,\n  isReference,\n  DocumentTransform,\n  canonicalStringify,\n  print,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport {\n  muteDeprecations,\n  warnRemovedOption,\n} from \"../../utilities/deprecation/index.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n\n    if (__DEV__) {\n      warnRemovedOption(\n        config,\n        \"addTypename\",\n        \"InMemoryCache\",\n        \"Please remove the `addTypename` option when initializing `InMemoryCache`.\"\n      );\n      warnRemovedOption(\n        config,\n        \"canonizeResults\",\n        \"InMemoryCache\",\n        \"Please remove the `canonizeResults` option when initializing `InMemoryCache`.\"\n      );\n    }\n\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    this.addTypenameTransform.resetCache();\n    fragments?.resetCaches();\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon:\n          resetResultIdentities ? void 0 : (\n            previousReader && previousReader.canon\n          ),\n        fragments,\n      })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.read\");\n    }\n\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return (\n        this.storeReader.diffQueryAgainstStore<T>({\n          ...options,\n          store: options.optimistic ? this.optimisticData : this.data,\n          config: this.config,\n          returnPartialData,\n        }).result || null\n      );\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables extends OperationVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>\n  ): Cache.DiffResult<TData> {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.diff\");\n    }\n\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    /**\n     * @deprecated `resetResultIdentities` is removed in Apollo Client 4.0.\n     *\n     * **Recommended now**\n     *\n     * Ensure all usages of `canonizeResults` are removed. Once\n     * `canonizeResults` is no longer used, remove this option.\n     */\n    resetResultIdentities?: boolean;\n  }) {\n    if (__DEV__) {\n      warnRemovedOption(\n        options || {},\n        \"resetResultIdentities\",\n        \"cache.gc\",\n        \"First ensure all usages of `canonizeResults` are removed, then remove this option.\"\n      );\n    }\n\n    canonicalStringify.reset();\n    print.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  private addTypenameToDocument(document: DocumentNode) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = muteDeprecations(\"canonizeResults\", () => this.diff<any>(c));\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n","import type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n} from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\nimport { iterateObserversSafely } from \"./iteration.js\";\nimport { fixObservableSubclass } from \"./subclassing.js\";\n\ntype MaybeAsync<T> = T | PromiseLike<T>;\n\nfunction isPromiseLike<T>(value: MaybeAsync<T>): value is PromiseLike<T> {\n  return value && typeof (value as any).then === \"function\";\n}\n\n// Any individual Source<T> can be an Observable<T> or a promise for one.\ntype Source<T> = MaybeAsync<Observable<T>>;\n\nexport type ConcastSourcesIterable<T> = Iterable<Source<T>>;\nexport type ConcastSourcesArray<T> = Array<Source<T>>;\n\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nexport class Concast<T> extends Observable<T> {\n  // Active observers receiving broadcast messages. Thanks to this.latest,\n  // we can assume all observers in this Set have received the same most\n  // recent message, though possibly at different times in the past.\n  private observers = new Set<Observer<T>>();\n\n  // This property starts off undefined to indicate the initial\n  // subscription has not yet begun, then points to each source\n  // subscription in turn, and finally becomes null after the sources have\n  // been exhausted. After that, it stays null.\n  private sub?: ObservableSubscription | null;\n\n  // Not only can the individual elements of the iterable be promises, but\n  // also the iterable itself can be wrapped in a promise.\n  constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>) {\n    super((observer) => {\n      this.addObserver(observer);\n      return () => this.removeObserver(observer);\n    });\n\n    // Suppress rejection warnings for this.promise, since it's perfectly\n    // acceptable to pay no attention to this.promise if you're consuming\n    // the results through the normal observable API.\n    this.promise.catch((_) => {});\n\n    // If someone accidentally tries to create a Concast using a subscriber\n    // function, recover by creating an Observable from that subscriber and\n    // using it as the source.\n    if (typeof sources === \"function\") {\n      sources = [new Observable(sources)];\n    }\n\n    if (isPromiseLike(sources)) {\n      sources.then((iterable) => this.start(iterable), this.handlers.error);\n    } else {\n      this.start(sources);\n    }\n  }\n\n  // A consumable array of source observables, incrementally consumed each time\n  // this.handlers.complete is called. This private field is not initialized\n  // until the concast.start method is called, which can happen asynchronously\n  // if a Promise is passed to the Concast constructor, so undefined is a\n  // possible value for this.sources before concast.start is called.\n  private sources: Source<T>[] | undefined;\n\n  private start(sources: ConcastSourcesIterable<T>) {\n    if (this.sub !== void 0) return;\n\n    // In practice, sources is most often simply an Array of observables.\n    // TODO Consider using sources[Symbol.iterator]() to take advantage\n    // of the laziness of non-Array iterables.\n    this.sources = Array.from(sources);\n\n    // Calling this.handlers.complete() kicks off consumption of the first\n    // source observable. It's tempting to do this step lazily in\n    // addObserver, but this.promise can be accessed without calling\n    // addObserver, so consumption needs to begin eagerly.\n    this.handlers.complete();\n  }\n\n  private deliverLastMessage(observer: Observer<T>) {\n    if (this.latest) {\n      const nextOrError = this.latest[0];\n      const method = observer[nextOrError];\n      if (method) {\n        method.call(observer, this.latest[1]);\n      }\n      // If the subscription is already closed, and the last message was\n      // a 'next' message, simulate delivery of the final 'complete'\n      // message again.\n      if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n\n  public addObserver(observer: Observer<T>) {\n    if (!this.observers.has(observer)) {\n      // Immediately deliver the most recent message, so we can always\n      // be sure all observers have the latest information.\n      this.deliverLastMessage(observer);\n      this.observers.add(observer);\n    }\n  }\n\n  public removeObserver(observer: Observer<T>) {\n    if (this.observers.delete(observer) && this.observers.size < 1) {\n      // In case there are still any listeners in this.nextResultListeners, and\n      // no error or completion has been broadcast yet, make sure those\n      // observers have a chance to run and then remove themselves from\n      // this.observers.\n      this.handlers.complete();\n    }\n  }\n\n  // Any Concast object can be trivially converted to a Promise, without\n  // having to create a new wrapper Observable. This promise provides an\n  // easy way to observe the final state of the Concast.\n  private resolve!: (result?: T | PromiseLike<T>) => void;\n  private reject!: (reason: any) => void;\n  public readonly promise = new Promise<T | undefined>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n\n  // Name and argument of the most recently invoked observer method, used\n  // to deliver latest results immediately to new observers.\n  private latest?: [\"next\", T] | [\"error\", any];\n\n  // Bound handler functions that can be reused for every internal\n  // subscription.\n  private handlers = {\n    next: (result: T) => {\n      if (this.sub !== null) {\n        this.latest = [\"next\", result];\n        this.notify(\"next\", result);\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    },\n\n    error: (error: any) => {\n      const { sub } = this;\n      if (sub !== null) {\n        // Delay unsubscribing from the underlying subscription slightly,\n        // so that immediately subscribing another observer can keep the\n        // subscription active.\n        if (sub) setTimeout(() => sub.unsubscribe());\n        this.sub = null;\n        this.latest = [\"error\", error];\n        this.reject(error);\n        this.notify(\"error\", error);\n        iterateObserversSafely(this.observers, \"error\", error);\n      }\n    },\n\n    complete: () => {\n      const { sub, sources = [] } = this;\n      if (sub !== null) {\n        // If complete is called before concast.start, this.sources may be\n        // undefined, so we use a default value of [] for sources. That works\n        // here because it falls into the if (!value) {...} block, which\n        // appropriately terminates the Concast, even if this.sources might\n        // eventually have been initialized to a non-empty array.\n        const value = sources.shift();\n        if (!value) {\n          if (sub) setTimeout(() => sub.unsubscribe());\n          this.sub = null;\n          if (this.latest && this.latest[0] === \"next\") {\n            this.resolve(this.latest[1]);\n          } else {\n            this.resolve();\n          }\n          this.notify(\"complete\");\n          // We do not store this.latest = [\"complete\"], because doing so\n          // discards useful information about the previous next (or\n          // error) message. Instead, if new observers subscribe after\n          // this Concast has completed, they will receive the final\n          // 'next' message (unless there was an error) immediately\n          // followed by a 'complete' message (see addObserver).\n          iterateObserversSafely(this.observers, \"complete\");\n        } else if (isPromiseLike(value)) {\n          value.then(\n            (obs) => (this.sub = obs.subscribe(this.handlers)),\n            this.handlers.error\n          );\n        } else {\n          this.sub = value.subscribe(this.handlers);\n        }\n      }\n    },\n  };\n\n  private nextResultListeners = new Set<NextResultListener>();\n\n  private notify(\n    method: Parameters<NextResultListener>[0],\n    arg?: Parameters<NextResultListener>[1]\n  ) {\n    const { nextResultListeners } = this;\n    if (nextResultListeners.size) {\n      // Replacing this.nextResultListeners first ensures it does not grow while\n      // we are iterating over it, potentially leading to infinite loops.\n      this.nextResultListeners = new Set();\n      nextResultListeners.forEach((listener) => listener(method, arg));\n    }\n  }\n\n  // We need a way to run callbacks just *before* the next result (or error or\n  // completion) is delivered by this Concast, so we can be sure any code that\n  // runs as a result of delivering that result/error observes the effects of\n  // running the callback(s). It was tempting to reuse the Observer type instead\n  // of introducing NextResultListener, but that messes with the sizing and\n  // maintenance of this.observers, and ends up being more code overall.\n  beforeNext(callback: NextResultListener) {\n    let called = false;\n    this.nextResultListeners.add((method, arg) => {\n      if (!called) {\n        called = true;\n        callback(method, arg);\n      }\n    });\n  }\n\n  // A public way to abort observation and broadcast.\n  public cancel = (reason: any) => {\n    this.reject(reason);\n    this.sources = [];\n    this.handlers.error(reason);\n  };\n}\n\ntype NextResultListener = (\n  method: \"next\" | \"error\" | \"complete\",\n  arg?: any\n) => any;\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n","import { \n  ApolloClient, \n  InMemoryCache, \n  HttpLink,\n  from,\n  ApolloLink\n} from '@apollo/client'\nimport { onError } from '@apollo/client/link/error'\nimport { RetryLink } from '@apollo/client/link/retry'\n\nconst GRAPHQL_ENDPOINT = process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT ?? 'http://localhost:8080/graphql'\n\n/**\n * Error handling link for GraphQL operations.\n * Logs errors to console for debugging.\n */\nconst errorLink = onError(({ graphQLErrors, networkError, operation }) => {\n  if (graphQLErrors) {\n    graphQLErrors.forEach(({ message, locations, path, extensions }) => {\n      console.error(\n        `[GraphQL error in ${operation.operationName}]: ${message}`,\n        { locations, path, extensions }\n      )\n    })\n  }\n  if (networkError) {\n    console.error(`[Network error]: ${networkError.message}`, networkError)\n  }\n})\n\n/**\n * Retry link for network failures.\n * Retries up to 3 times with exponential backoff.\n */\nconst retryLink = new RetryLink({\n  delay: {\n    initial: 300,\n    max: 5000,\n    jitter: true\n  },\n  attempts: {\n    max: 3,\n    retryIf: (error) => {\n      // Don't retry on 4xx errors or GraphQL validation errors\n      if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n        return false\n      }\n      return !!error\n    }\n  }\n})\n\n/**\n * HTTP link for GraphQL endpoint.\n * Includes credentials for CORS requests.\n */\nconst httpLink = new HttpLink({\n  uri: GRAPHQL_ENDPOINT,\n  credentials: 'include'\n})\n\nexport const apolloClient = new ApolloClient({\n  link: from([errorLink, retryLink, httpLink]),\n  cache: new InMemoryCache(),\n  defaultOptions: {\n    watchQuery: {\n      errorPolicy: 'all'\n    },\n    query: {\n      errorPolicy: 'all'\n    }\n  }\n})\n\n","import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders: Record<string, string> = {};\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData: Record<string, { originalName: string; value: string }> =\n    {};\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders: Record<string, string> = {};\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n","import { isNonNullObject } from \"./objects.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A\n  : T extends [infer A, infer B] ? A & B\n  : T extends [infer A, infer B, infer C] ? A & B & C\n  : T extends [infer A, infer B, infer C, infer D] ? A & B & C & D\n  : T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E\n  : T extends (infer U)[] ? U\n  : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || ({} as T);\n  const count = sources.length;\n  if (count > 1) {\n    const merger = new DeepMerger();\n    for (let i = 1; i < count; ++i) {\n      target = merger.merge(target, sources[i]);\n    }\n  }\n  return target;\n}\n\nexport type ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler as any as ReconcilerFunction<TContextArgs>\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(\n              target,\n              source,\n              sourceKey,\n              ...context\n            );\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n","import type { DocumentNode, FieldNode } from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n  isReference,\n  AsStoreObject,\n  DeepPartial,\n} from \"../../../utilities/index.js\";\n\nimport type { StorageType } from \"../../inmemory/policies.js\";\n\n// The Readonly<T> type only really works for object types, since it marks\n// all of the object's properties as readonly, but there are many cases when\n// a generic type parameter like TExisting might be a string or some other\n// primitive type, in which case we need to avoid wrapping it with Readonly.\n// SafeReadonly<string> collapses to just string, which makes string\n// assignable to SafeReadonly<any>, whereas string is not assignable to\n// Readonly<any>, somewhat surprisingly.\nexport type SafeReadonly<T> = T extends object ? Readonly<T> : T;\n\nexport type MissingTree =\n  | string\n  | {\n      readonly [key: string]: MissingTree;\n    };\n\nexport class MissingFieldError extends Error {\n  constructor(\n    public readonly message: string,\n    public readonly path: MissingTree | Array<string | number>,\n    public readonly query: DocumentNode,\n    public readonly variables?: Record<string, any>\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    if (Array.isArray(this.path)) {\n      this.missing = this.message;\n      for (let i = this.path.length - 1; i >= 0; --i) {\n        this.missing = { [this.path[i]]: this.missing };\n      }\n    } else {\n      this.missing = this.path;\n    }\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    (this as any).__proto__ = MissingFieldError.prototype;\n  }\n\n  public readonly missing: MissingTree;\n}\n\nexport interface FieldSpecifier {\n  typename?: string;\n  fieldName: string;\n  field?: FieldNode;\n  args?: Record<string, any>;\n  variables?: Record<string, any>;\n}\n\nexport interface ReadFieldOptions extends FieldSpecifier {\n  from?: StoreObject | Reference;\n}\n\nexport interface ReadFieldFunction {\n  <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\n  <V = StoreValue>(\n    fieldName: string,\n    from?: StoreObject | Reference\n  ): SafeReadonly<V> | undefined;\n}\n\nexport type ToReferenceFunction = (\n  objOrIdOrRef: StoreObject | string | Reference,\n  mergeIntoStore?: boolean\n) => Reference | undefined;\n\nexport type CanReadFunction = (value: StoreValue) => boolean;\n\ndeclare const _deleteModifier: unique symbol;\nexport interface DeleteModifier {\n  [_deleteModifier]: true;\n}\ndeclare const _invalidateModifier: unique symbol;\nexport interface InvalidateModifier {\n  [_invalidateModifier]: true;\n}\ndeclare const _ignoreModifier: unique symbol;\nexport interface IgnoreModifier {\n  [_ignoreModifier]: true;\n}\n\nexport type ModifierDetails = {\n  DELETE: DeleteModifier;\n  INVALIDATE: InvalidateModifier;\n  fieldName: string;\n  storeFieldName: string;\n  readField: ReadFieldFunction;\n  canRead: CanReadFunction;\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n  storage: StorageType;\n};\n\nexport type Modifier<T> = (\n  value: T,\n  details: ModifierDetails\n) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;\n\ntype StoreObjectValueMaybeReference<StoreVal> =\n  StoreVal extends Array<Record<string, any>> ?\n    StoreVal extends Array<infer Item> ?\n      [Item] extends [Record<string, any>] ?\n        ReadonlyArray<AsStoreObject<Item> | Reference>\n      : never\n    : never\n  : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference\n  : StoreVal;\n\nexport type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<\n  Entity[keyof Entity] extends infer Value ?\n    StoreObjectValueMaybeReference<Exclude<Value, undefined>>\n  : never\n>;\n\nexport type Modifiers<T extends Record<string, any> = Record<string, unknown>> =\n  Partial<{\n    [FieldName in keyof T]: Modifier<\n      StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>\n    >;\n  }>;\n","import type { FormattedExecutionResult, GraphQLFormattedError } from \"graphql\";\n\nimport {\n  graphQLResultHasProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n} from \"../../errors/index.js\";\nimport type { NetworkError } from \"../../errors/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type { Operation, FetchResult, NextLink } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\n\nexport interface ErrorResponse {\n  /**\n   * Errors returned in the `errors` property of the GraphQL response.\n   *\n   * @deprecated `graphQLErrors` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `graphQLErrors` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  /**\n   * Errors thrown during a network request. This is usually an error thrown\n   * during a `fetch` call or an error while parsing the response from the\n   * network.\n   *\n   * @deprecated `networkError` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `networkError` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  networkError?: NetworkError;\n  /**\n   * Fatal transport-level errors from multipart subscriptions.\n   * See the [multipart subscription protocol](https://www.apollographql.com/docs/graphos/routing/operations/subscriptions/multipart-protocol#message-and-error-format) for more information.\n   *\n   * @deprecated `protocolErrors` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `protocolErrors` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  protocolErrors?: ReadonlyArray<GraphQLFormattedError>;\n\n  /**\n   * @deprecated `response` has renamed to `result` in Apollo Client 4.0. This\n   * property is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When migrating**\n   *\n   * Use the `result` property instead of `response` inside your callback function.\n   */\n  response?: FormattedExecutionResult;\n  operation: Operation;\n  forward: NextLink;\n}\n\nexport namespace ErrorLink {\n  /**\n   * Callback to be triggered when an error occurs within the link stack.\n   */\n  export interface ErrorHandler {\n    (error: ErrorResponse): Observable<FetchResult> | void;\n  }\n}\n\n// For backwards compatibility.\nexport import ErrorHandler = ErrorLink.ErrorHandler;\n\nexport function onError(errorHandler: ErrorHandler): ApolloLink {\n  return new ApolloLink((operation, forward) => {\n    return new Observable((observer) => {\n      let sub: any;\n      let retriedSub: any;\n      let retriedResult: any;\n\n      try {\n        sub = forward(operation).subscribe({\n          next: (result) => {\n            if (result.errors) {\n              retriedResult = errorHandler({\n                graphQLErrors: result.errors,\n                response: result,\n                operation,\n                forward,\n              });\n            } else if (graphQLResultHasProtocolErrors(result)) {\n              retriedResult = errorHandler({\n                protocolErrors: result.extensions[PROTOCOL_ERRORS_SYMBOL],\n                response: result,\n                operation,\n                forward,\n              });\n            }\n\n            if (retriedResult) {\n              retriedSub = retriedResult.subscribe({\n                next: observer.next.bind(observer),\n                error: observer.error.bind(observer),\n                complete: observer.complete.bind(observer),\n              });\n              return;\n            }\n\n            observer.next(result);\n          },\n          error: (networkError) => {\n            retriedResult = errorHandler({\n              operation,\n              networkError,\n              //Network errors can return GraphQL errors on for example a 403\n              graphQLErrors:\n                (networkError &&\n                  networkError.result &&\n                  networkError.result.errors) ||\n                void 0,\n              forward,\n            });\n            if (retriedResult) {\n              retriedSub = retriedResult.subscribe({\n                next: observer.next.bind(observer),\n                error: observer.error.bind(observer),\n                complete: observer.complete.bind(observer),\n              });\n              return;\n            }\n            observer.error(networkError);\n          },\n          complete: () => {\n            // disable the previous sub from calling complete on observable\n            // if retry is in flight.\n            if (!retriedResult) {\n              observer.complete.bind(observer)();\n            }\n          },\n        });\n      } catch (e) {\n        errorHandler({ networkError: e as Error, operation, forward });\n        observer.error(e);\n      }\n\n      return () => {\n        if (sub) sub.unsubscribe();\n        if (retriedSub) sub.unsubscribe();\n      };\n    });\n  });\n}\n\nexport class ErrorLink extends ApolloLink {\n  private link: ApolloLink;\n  constructor(errorHandler: ErrorLink.ErrorHandler) {\n    super();\n    this.link = onError(errorHandler);\n  }\n\n  public request(\n    operation: Operation,\n    forward: NextLink\n  ): Observable<FetchResult> | null {\n    return this.link.request(operation, forward);\n  }\n}\n","export type ServerError = Error & {\n  response: Response;\n  /**\n   * @deprecated `result` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When migrating**\n   *\n   * `result` has been replaced by `bodyText` which is the raw string body\n   * returned in the result. Use `JSON.parse` on the `bodyText` property to get\n   * the same value as `result`.\n   */\n  result: Record<string, any> | string;\n  statusCode: number;\n};\n\n/**\n * @deprecated `throwServerError` will be removed in Apollo Client 4.0. This is\n * safe to use in Apollo Client 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When migrating**\n *\n * `ServerError` is a subclass of `Error`. To throw a server error, use\n * `throw new ServerError(...)` instead.\n *\n * ```ts\n * throw new ServerError(\"error message\", { response, result });\n * ```\n */\nexport const throwServerError = (\n  response: Response,\n  result: any,\n  message: string\n) => {\n  const error = new Error(message) as ServerError;\n  error.name = \"ServerError\";\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n  throw error;\n};\n"],"names":[],"mappings":"sD6B8qBgB,IAAM,CAAC,0JC5pBkB,4EAK3B,GAAU,EAAc,MAAM,GACtC,wITN8B,CAAA,6CAIpB,CAAA,sCACmD,4GAQ9C,CAAA,kBACV,IAAA,EAAA,kBAAqB,EAAA,UAAU,CAAC,EAAE,EAAb,WAG9B,SAAA,CAAA,yDAEmC,CAAC,CaaT,CAAA,EbbiB,OAAA,EAAE,MAAM,CAAC,EAAT,sBAIV,CAChC,CAAA,CAAA,CACmC,aAG7B,EAAA,EAAA,GAAA,IAAgC,EAAA,qCAGP,EAAA,GACR,SAAC,CaSc,AuB8DZ,CvB9Da,CuB8Db,qBpCrEF,CAAA,IAAA,EAAA,UAAyB,CAAC,C2B4EQ,AFjFT,CAAA,GAAA,EAAA,OAAA,CAAA,IAAA,EAAA,UAAA,CAAA,EAAA,IzBSzC,SAAgB,CAAS,CAAA,CAAA,8BAEe,EAAA,UAAA,CAAA,EAAA,GAAA,EAAA,OAAA,CAAA,EAAA,IACC,EAAA,UAAU,CAAC,EAAE,oBAGF,yBAK5D,CAAyB,QH/DvB,wBGkEY,CACV,GACE,EAAU,OAAA,EHpEd,EAAA,WCCS,GEoEc,kHE9DW,CAAA,IAAE,eACF,4DF6DO,IFpEhC,KEoEyC,CAAC,CAAC,CACjD,CACF,AFtEQ,EAAA,CAAA,mKAUoC,CIFG,AeiEM,AnB/DR,CWeO,C1BoDD,A0BnDvD,KXhBqD,EAAA,EAAA,+EOExC,oBARV,uBAAA,CAAA,EAAA,EAAA,QAAA,EAAA,CAAA,EAAA,EAAA,QAAA,EAAA,CAAA,EAAA,GAAA,EAAA,qCAEe,GAAA,mGAGqC,EAAN,AfmBE,AQnBF,COAgB,CAAC,AyBgBA,CAAC,CzBJ7D,A6BQ8D,CrBRhE,IbiDI,EAAA,UAAU,CAAC,EAAE,EAAE,CACrB,CAAC,mBAIgC,CAClC,CAAmC,CyBfhB,iBzBkBD,yDAKT,sCAMD,OAAA,SAAA,CAAA,SAEF,EAAA,OAAiB,CAAA,EAEf,SAAC,CaF8C,EbEvC,OAAA,EAAS,OAAA,CAAQ,CW6R/B,CX7RiC,CAAC,CAAI,EW6RjC,AAoBH,AAAO,OAAA,GXjTuC,CAAC,EAAE,EW6R9C,AX7RgD,AAAvC,CAAuC,CAChD,EAAI,EAAA,UAAU,CAAA,EAAG,CWgTpB,CXnTE,AAGoB,MWgTf,QX7S+B,UW0RvB,EACjB,KAkBE,OAAO,MX3SyB,CAAE,CUwGhB,ACiLL,EAAf,OAAO,CXxRe,CW8Sb,MAAA,CAAA,EAAA,IAAA,EAAA,EAtBC,KAAK,GXxRyC,CAAA,CWwRzC,CXxRyC,CWyRxD,KAiBE,OAAO,QXzSc,WWwRD,EXpRqB,AWoR3C,MXpR2C,YWoRzB,mBAAG,CX5QvB,AW4QwB,CX5QxB,CAAA,CAAA,CAEA,CAAA,AW0QwB,uBXvQX,KAAK,CAAA,EAAO,EAAM,GAAS,IAAI,C0BgIlC,CAAA,4C1B3HH,EcwDM,AdxDK,MAAA,CAAA,IAAA,CAAA,iCAIlB,CAAoB,CAAA,CACF,uDASH,CAAjB,SACE,CAAU,CACV,CAAgC,CgB5DqB,CAAC,GhB8DxC,CAAA,eAAA,OAAA,qBACE,EAAC,UAAA,+EAON,CYgQG,AjBxPF,IAAA,CAAA,YKEN,oCAOmC,oFAMpC,OAAA,CAAA,EACE,IAAA,wDD5K6B,CAAA,CAAA,CAAA,YAGpC,EAAA,KAAA,SAAA,CAAA,SACO,EAAQ,6BACqB,EAAA,GAAA,EAAA,EAAA,OAAA,mClBV3B,CCDD,CGDC,ADAA,AEAA,AHAA,AFEY,CgBDD,AVAV,ALAA,AcMU,CENC,AbDV,ACAA,AHAA,ACAA,CYOW,AMPA,AHAA,AjBCA,AQDA,AUAA,ACAA,AZKA,AQJA,CJDC,AFCA,AGDA,AFAA,AMCA,AXAA,CYDC,ACAA,ACAA,ACAA,CPoBnB,ARnBoB,CFDC,ACAA,CDAC,AUqB7B,ATrB6B,AFAA,CYOC,CfJV,CcmBpB,CdlByD,EQCF,CAAC,CSJC,CRDC,AQCA,CRDC,ITMjC,AcgBJ,EACtB,CIvBkE,AGAA,ADAA,CCAC,ADAA,AFAA,CIAC,CAAC,ItBM3C,GACC,CMAC,AuBJA,AzBMA,AFPA,A4BGA,AHHA,AIcP,AZhBwD,CAAC,ALuBjE,CiBPQ,CjBQrB,WdbW,IcaI,EACf,OAAO,EACP,IdfW,aceM,EACjB,sBAAsB,EACtB,OAAO,GACR,MAAM,0BAA0B,CAAC,kH0CShC,CAAA,CACA,CAAA,6BAGU,CAAG,CbbH,eacJ,QAAA,CAAA,0BAEA,MAAA,CAAA,EACA,8NHFK,CAAC,AvCeF,CAAA,EAAA,EuCfY,EAAA,EAAA,gBACoB,EAAA,SAGnC,+BAgBA,IAAA,CAAA,KAAU,CAAC,CAAA,CAAA,EAAA,CAAA,CAAwB,CAAA,EAAA,GVtB3C,EAAA,uBU2BsH,mCAAjG,CAAA,gBAqCF,EAAA,eAAA,4DAlCM,CAAA,CAAA,yHACwB,EAAA,SAAU,CAAC,CAChD,IAAI,CAAA,GAAA,OAAA,CAAA,SAAA,CAAA,oCAGc,GAAA,EAAkB,CACrC,IAAA,EAAA,EAAA,UAAA,CAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,aAAA,EAAA,CACE,cPyFS,IAAA,IOhFT,CjBsGS,AjBnGI,AoCwDZ,AF5DD,EAAS,CTVP,AVoBgB,AYyEE,Af+Lb,CAAA,IsBnRmB,etBmRnB,CAAA,EAAA,CwBtNN,CAAA,EF3DgB,CpByEW,CAAA,YoBnElB,mBAAA,CAAA,EAAA,OACa,EAAU,wCAenB,CAAA,SAAA,CAAA,4EAGF,KACO,KAAA,CAAM,mBAG3B,UAAA,OAAA,cAAgC,CAAC,GxBqHsB,mBwBjH5C,CAAC,GAAG,CAAC,IAGjB,IAEX,CAAC,AA3DD,qDtCzBmB,CACjB,CAAmC,QAElB,6CAIC,EAAA,WAAkB,iBAEf,OAAA,CAAA,SAAA,CAAuB,2BAAF,cACR,GAAK,CwC+DlB,AxC/DmB,CAAA,EAAI,EAAA,cAEhB,AACuB,CsCSlB,KAAA,CtCVE,GACmC,CAAA,EAAnB,EAAiB,CAAC,CAAC,MAEhE,CdCS,CAAA,mBcIR,wC6ByEH,SAAA,EAAA,CAAA,CAA+C,CAAgB,EfqJ/C,EepJP,Cd2WH,KAAA,Ec3Wa,yCAIA,CAAA,SACV,EAAA,cAOT,CxC6EqB,gDAAA,MAAA,CwC7E4B,EAAS,MAAD,AAAO,CAAE,CACnE,CAAC,WAIK,KAAK,KAAK,CAAC,EACpB,CV0CC,AU1CA,AC+LA,MAAA,EAAA,ODzLO,EAJK,IAAI,CAAG,kCAEP,UAAA,CAAA,EAAA,MAAA,WACQ,CAAG,EAJH,EAOvB,CxC8EC,AwC9EA,qF9ClKD,EAAA,EAAA,CAAA,CAAA,OwCQA,IAAM,EAAgB,gCAEtB,SAAS,EAAgB,CAAG,EAC1B,OAAO,CAAe,CAAC,EAAI,UAAU,CAAC,GAAG,AAC3C,CAEA,CAFE,GAEI,EAAkB,CACtB,UACA,EAJkB,QAKlB,UACA,UACA,UACA,UACA,UACA,UACA,MACA,MACA,MACA,UACA,MACA,MACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,GACA,GACA,MACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,OACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACD,CxC7KD,IAAA,EAAA,EAAA,CAAA,CAAA,OAUA,IAAM,EAAqB,CACzB,KAAM,CACJ,MAAO,AAAC,GAAS,EAAK,KAAK,AAC7B,EACA,SAAU,CACR,MAAQ,AAAD,GAAU,IAAM,EAAK,IAAI,AAClC,EAEA,SAAU,CACR,MAAO,AAAC,GAAS,EAAK,EAAK,WAAW,CAAE,OAC1C,EACA,oBAAqB,CACnB,MAAM,CAAI,EACR,IAAM,EAAU,EAAkB,EAAK,mBAAmB,EACtD,EAAK,MAAO,EAAK,EAAK,mBAAmB,CAAE,MAAO,OAClD,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","ignoreList":[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58]}